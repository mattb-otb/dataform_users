config { 
    type: "table",
    schema: constants.DATAFORM_LV1,
    description: "Stage for GA user data.",
    tags: ["daily-update", "bronze"],
    bigquery: {
        labels: {environment: "bronze"}
    },
}

js {var{tracked_platform} = require("includes/tracked_platform");}

WITH
-- Get user_ids to join to sessions
users_all AS(
SELECT
  user_pseudo_id,
  user_id,
  ga_session_id,
  MAX(event_timestamp) AS max_timestamp
FROM ${ref("src_ga4_events_combined")} 
WHERE
  event_date BETWEEN '2023-07-01'
  AND DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)
  AND brand = 'OTB UK'
  AND REGEXP_CONTAINS(user_id, r'[A-Z]') = FALSE
  AND user_pseudo_id IS NOT NULL
  AND ga_session_id IS NOT NULL
GROUP BY ALL
),

-- start of back fill for user_id
user_window AS (
  SELECT
    *,
    FIRST_VALUE(user_id IGNORE NULLS) OVER 
      (PARTITION BY user_pseudo_id ORDER BY max_timestamp ASC ROWS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING) AS next_non_null_user_id,   
  FROM users_all
),

-- fill missing user_ids, concat to get session IDs
user_fill AS (
SELECT 
  user_pseudo_id,
  ga_session_id,
  COALESCE(user_id, next_non_null_user_id) AS user_id,
  CONCAT(user_pseudo_id, ga_session_id) AS device_session_id,
  MAX(max_timestamp) AS max_timestamp,
FROM user_window  
GROUP BY ALL
),

find_last_user_id AS (
SELECT 
* EXCEPT (user_id),
FIRST_VALUE(user_id) OVER (PARTITION BY device_session_id ORDER BY max_timestamp DESC) AS user_id
FROM user_fill
),

group_by_session_id AS (
SELECT 
device_session_id,
user_id
FROM find_last_user_id
GROUP BY ALL
),

sessions_all AS (
SELECT 
    s.date,
    s.user_id AS user_pseudo_id,
    g.user_id, -- <-- bring in the user_id from group_by_session_id
    s.session_id,
    s.website_version,
    order_code,
    TIMESTAMP_TRUNC(s.session_start, SECOND) AS session_timestamp,
    s.session_start,
    s.channel,
    s.source,
    s.medium,
    s.campaign,
    s.campaign_id,
    s.order_count,
    s.pageviews,
    s.landing_pageviews,
    s.create_account_events,
    s.login_events,
    s.deal_search_events,
    s.bounced_session
FROM ${ref("tbl_sessions")} AS s
LEFT JOIN group_by_session_id AS g
ON s.session_id = g.device_session_id
LEFT JOIN UNNEST(SPLIT(s.order_codes, ",")) AS order_code
WHERE s.market = 'On The Beach'
AND s.ga_platform = 'GA4'
AND s.date >= '2023-06-01'
),

-- Get order data
source_orders AS (
  SELECT
    order_code,
    departure_date,
    repeat_booking_ind AS repeat_booking_mi,
    gross_margin AS profit,
    gross_revenue AS revenue,
    DestinationCountry,
    DestinationRegion,
    passenger_group,
    pax,
    hotel,
    HotelBoardBasis,
    holiday_type,
    TIMESTAMP_ADD(departure_date, INTERVAL duration DAY) AS return_date,
    duration
  FROM ${ref("tbl_orders")}
  WHERE
    CurrentVersionInd IS TRUE
    AND country_code IN('GB')
    AND brand IN ('On The Beach')
    AND test_booking_ind IS NOT TRUE
    AND order_source <> 'OTP' 
    AND date >= '2023-06-01'
),

-- Combining the two to pull in return holiday dates, profit and revenue
full_data AS (
  SELECT
    a.date,
    a.session_timestamp,
    a.user_pseudo_id,
    a.user_id,
    a.session_id,
    a.channel,
    a.source,
    a.medium,
    a.campaign,
    a.campaign_id,
    ${tracked_platform("a.source", "a.medium", "a.channel")}  AS tracked_platform,
    a.website_version,
    b.order_code,
    CASE WHEN b.order_code IS NOT NULL THEN 1 ELSE 0 END AS order_flag,
    a.bounced_session,
    a.pageviews,
    a.landing_pageviews,
    a.create_account_events,
    a.login_events,
    a.deal_search_events,
  -- Joined order data
    b.repeat_booking_mi,
    b.departure_date,
    b.duration,
    b.return_date,
    b.profit,
    b.revenue,
    b.DestinationCountry AS destination_country,
    b.DestinationRegion AS destination_region,
    b.passenger_group AS passenger_group,
    b.pax,
    b.hotel,
    b.HotelBoardBasis AS hotel_board_type,
    b.holiday_type,
  FROM sessions_all a
  LEFT JOIN source_orders b
  ON a.order_code = b.order_code
),

orders_per_day AS (
  SELECT
    user_id,
    date,
    MAX(order_flag) AS has_order_that_day
  FROM full_data
  GROUP BY user_id, date
),

join_order_date_flag AS (
  SELECT
    a.*,
    b.has_order_that_day AS daily_order_flag
  FROM full_data AS a
  LEFT JOIN orders_per_day AS b
    ON a.user_id = b.user_id
    AND a.date = b.date
),

-- Flatten out the duplicate order codes in a session, and take the sums/max across multiple order codes, add order window.
full_data_flat AS (
  SELECT
  -- Groups
    date,
    session_id,
    ANY_VALUE(user_id) AS user_id,
    ANY_VALUE(user_pseudo_id) AS user_pseudo_id,
    ANY_VALUE(channel) AS channel,
    ANY_VALUE(source) AS source,
    ANY_VALUE(medium) AS medium,
    ANY_VALUE(campaign) AS campaign,
    ANY_VALUE(campaign_id) AS campaign_id,
    ANY_VALUE(tracked_platform) AS tracked_platform,
    SAFE_CAST(LOGICAL_AND(repeat_booking_mi) AS INT64) AS repeat_booking_mi,
    MIN(session_timestamp) AS session_timestamp,
    MAX(order_flag) AS order_flag,
    MAX(website_version) AS website_version,
    MAX(daily_order_flag) AS daily_order_flag,
    STRING_AGG(order_code, ', ') AS order_codes,
  -- Calculations
    SUM(order_flag) AS order_count,
    ANY_VALUE(bounced_session) AS bounced_session,
    ANY_VALUE(pageviews) AS pageviews,
    ANY_VALUE(landing_pageviews) AS landing_pageviews,
    ANY_VALUE(create_account_events) AS create_account_events,
    ANY_VALUE(login_events) AS login_events,
    ANY_VALUE(deal_search_events) AS deal_search_events,
    MAX(departure_date) AS departure_date,
    MAX(duration) AS duration,
    MAX(return_date) AS return_date,
    SUM(profit) AS profit,
    SUM(revenue) AS revenue,
    MAX(destination_country) AS destination_country,
    MAX(destination_region) AS destination_region,
    MAX(passenger_group) AS passenger_group,
    MAX(pax) AS pax,
    MAX(hotel) AS hotel,
    MAX(hotel_board_type) AS hotel_board_type,
    MAX(holiday_type) AS holiday_type
  FROM join_order_date_flag  
  GROUP BY date, session_id
),

-- Add campaign and affiliate types
-- get affiliate IDs and types from a gsheet
aff_ids AS (
  SELECT DISTINCT
  publisher_id,
  type,
  'AWIN' AS platform 
  FROM ${ref("LIVE_affiliate_publisher_ids_otb")}
),

add_campaign_type AS (
SELECT 
   a.*,
  CASE
    WHEN tracked_platform IN('Google Ads', 'Bing Ads') AND REGEXP_CONTAINS(LOWER(campaign), 'destination') THEN 'Destination'
    WHEN tracked_platform IN('Google Ads', 'Bing Ads') AND REGEXP_CONTAINS(LOWER(campaign), 'top.150') THEN 'Top 150 Hotels'
    WHEN tracked_platform IN('Google Ads', 'Bing Ads') AND REGEXP_CONTAINS(LOWER(campaign), 'top.500') THEN 'Top 500 Hotels'
    WHEN tracked_platform IN('Google Ads', 'Bing Ads') AND REGEXP_CONTAINS(LOWER(campaign), 'hotel.names') THEN 'Hotel Names'
    WHEN tracked_platform IN('Google Ads', 'Bing Ads') AND REGEXP_CONTAINS(LOWER(campaign), 'hotel') THEN 'Hotel'
    WHEN tracked_platform IN('Google Ads', 'Bing Ads') AND REGEXP_CONTAINS(LOWER(campaign), 'generic') THEN 'Generic'
    WHEN tracked_platform IN('Google Ads', 'Bing Ads') AND REGEXP_CONTAINS(LOWER(campaign), 'core') THEN 'Core'
    WHEN tracked_platform IN('Google Ads', 'Bing Ads') AND REGEXP_CONTAINS(LOWER(campaign), 'holiday') THEN 'Holiday'
    WHEN tracked_platform IN('Google Ads', 'Bing Ads') AND REGEXP_CONTAINS(LOWER(campaign), '^sf.*') THEN 'Supplier Funded'
    WHEN tracked_platform IN('Google Ads', 'Bing Ads') THEN 'Unknown'
    WHEN tracked_platform = 'AWIN' THEN COALESCE(INITCAP(b.type), 'Unknown')
    WHEN tracked_platform = 'Partnerize' THEN COALESCE(INITCAP(b.type), 'Unknown')
    WHEN tracked_platform = 'TravelSupermarket' THEN 'TravelSupermarket'
    WHEN tracked_platform = 'Icelolly' THEN 'Icelolly'
    WHEN tracked_platform = 'TravelZoo' THEN 'TravelZoo'
    WHEN tracked_platform = 'Skyscanner' THEN 'Skyscanner'
    WHEN tracked_platform = 'Dealchecker' THEN 'Dealchecker'
    WHEN tracked_platform = 'Adup' THEN 'Prospecting'
    WHEN tracked_platform = 'Tradedoubler' THEN 'Tradedoubler'
    WHEN tracked_platform = 'HolidayExtras' THEN 'HolidayExtras'
    WHEN tracked_platform = 'Clicktripz' THEN 'Clicktripz'
    WHEN tracked_platform IN('Facebook Ads', 'TikTok') AND REGEXP_CONTAINS(LOWER(campaign), '^sf.*') THEN 'Supplier Funded'
    WHEN tracked_platform IN('Facebook Ads', 'TikTok') AND LOWER(campaign) LIKE '%prospecting%' THEN 'Prospecting'
    WHEN tracked_platform IN('Facebook Ads', 'TikTok') AND LOWER(campaign) LIKE '%retargeting%' THEN 'Retargeting'
    WHEN tracked_platform IN('Facebook Ads', 'TikTok') AND LOWER(campaign) LIKE '%rtg%' THEN 'Retargeting'
    WHEN tracked_platform IN('Facebook Ads', 'TikTok') AND LOWER(campaign) LIKE '%tof%' THEN 'Prospecting'
    WHEN tracked_platform IN('Facebook Ads', 'TikTok') AND LOWER(campaign) LIKE '%awareness%' THEN 'Awareness'
    WHEN tracked_platform IN('Facebook Ads', 'TikTok') AND LOWER(campaign) LIKE '%instagram%' THEN 'Instagram Post'
    WHEN tracked_platform IN('Facebook Ads', 'TikTok') AND LOWER(campaign) LIKE '%reach%' THEN 'Awareness'
    WHEN tracked_platform = 'YouTube' THEN 'YouTube'
    WHEN tracked_platform = 'Adup' THEN 'Unknown'
    WHEN LOWER(campaign) LIKE '%prospecting%' THEN 'Prospecting'
    WHEN LOWER(campaign) LIKE '%retargeting%' THEN 'Retargeting'
    WHEN LOWER(campaign) LIKE '%rtg%' THEN 'Retargeting'
    WHEN LOWER(campaign) LIKE '%tof%' THEN 'Prospecting'
    WHEN LOWER(campaign) LIKE '%awareness%' THEN 'Awareness'
    WHEN LOWER(campaign) LIKE '%instagram%' THEN 'Instagram Post'
  ELSE 'Unknown' END AS campaign_type,
FROM full_data_flat AS a
 LEFT JOIN aff_ids AS b
  ON a.tracked_platform = b.platform
  AND campaign_id = publisher_id
   ),

-- Join Bloomreach
-- Get Bloomreach IDs
bloomreach_ids AS (
SELECT 
   MIN(internal_customer_id) AS internal_customer_id,
   LOWER(id_value) AS id_value
FROM ${ref("bloomreach_ids")} 
GROUP BY ALL
),

join_bloomreach_ids AS (
  SELECT 
    a.*,
    b.internal_customer_id AS bloomreach_id
  FROM add_campaign_type AS a
  LEFT JOIN bloomreach_ids AS b
    ON COALESCE(LOWER(a.user_id), LOWER(a.user_pseudo_id)) = b.id_value
  GROUP BY ALL
),

get_best_user_id AS (
SELECT
    *,
    COALESCE(bloomreach_id, user_id, user_pseudo_id) AS best_id
FROM join_bloomreach_ids        
),

add_rolling_window AS (
SELECT
  *,
  SUM(order_flag) OVER (PARTITION BY best_id ORDER BY session_timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS rolling_order_window
FROM get_best_user_id
),

-- Add first order window lag because some metrics use a pre-purchase window, some a post-purchase window
window_lag AS (
  SELECT 
    *,
     LAG(rolling_order_window, 1, 0) OVER (PARTITION BY best_id ORDER BY session_timestamp) AS first_order_window
  FROM add_rolling_window  
),

-- DEDUPED CHANNEL PURCHASE PATHS FOR A USER
-- Get previous channel in the order window
previous_channel AS (
  SELECT
    best_id,
    session_timestamp,
    channel,
    first_order_window,
    LAG(channel) OVER (PARTITION BY best_id, first_order_window ORDER BY session_timestamp) AS prev_channel
  FROM window_lag
),

-- All channels in purchase path
all_channels_in_path AS (
SELECT 
  best_id,
  first_order_window,
  STRING_AGG(channel, ' / ' ORDER BY session_timestamp) AS ordered_channels
FROM previous_channel 
GROUP BY best_id, first_order_window
),

-- Remove duplicate channels, so if a user hits a channel twice in a row, it will only count once.
dedupe AS (
SELECT 
  best_id,
  first_order_window,
  STRING_AGG(channel, ' / ' ORDER BY session_timestamp) AS ordered_channels
FROM previous_channel
WHERE channel != prev_channel OR prev_channel IS NULL  -- Remove consecutive duplicates
GROUP BY ALL
),

-- Get non direct channel list
nondirect_channels_in_path AS (
  SELECT 
    best_id,
    first_order_window,
    STRING_AGG(channel, ' / ' ORDER BY session_timestamp) AS ordered_channels
  FROM previous_channel
  WHERE channel != 'Brand - Direct'
  GROUP BY best_id, first_order_window
),

-- join back to the user and their order window
join_channels_to_main_branch AS (
  SELECT 
    a.*,
    b.ordered_channels AS order_channel_path,
    c.ordered_channels AS order_channel_path_full,
    COALESCE(d.ordered_channels, 'Brand - Direct') AS order_channel_path_nondirect
  FROM window_lag AS a
  LEFT JOIN dedupe AS b
    ON a.best_id = b.best_id
    AND a.first_order_window = b.first_order_window
  LEFT JOIN all_channels_in_path AS c
    ON a.best_id = c.best_id
    AND a.first_order_window = c.first_order_window
  LEFT JOIN nondirect_channels_in_path AS d
    ON a.best_id = d.best_id
    AND a.first_order_window = d.first_order_window
),

-- WINDOW CALCULATIONS
-- Bring in all the user window calculations
window_calculations AS (
  SELECT 
    *,
    COUNT(DISTINCT session_id) OVER (PARTITION BY best_id, first_order_window) AS session_count,
    DATE_DIFF(
      LAST_VALUE(session_timestamp) OVER (PARTITION BY best_id, first_order_window ORDER BY session_timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING),
      FIRST_VALUE(session_timestamp) OVER (PARTITION BY best_id, first_order_window ORDER BY session_timestamp), DAY)+1 AS orders_window_days,
    CASE -- Engaged session flag
      WHEN (deal_search_events >= 1 OR pageviews >= 2 OR login_events > 0 OR create_account_events > 0 OR order_count > 0) THEN TRUE
    ELSE FALSE END AS engaged_flag, 
    SPLIT(order_channel_path, ' / ')[SAFE_OFFSET(0)] AS first_channel_order_window,
    SPLIT(order_channel_path, ' / ')[SAFE_OFFSET(ARRAY_LENGTH(SPLIT(order_channel_path, ' / ')) - 1)] AS last_channel_order_window,
    SPLIT(order_channel_path_nondirect, ' / ')[SAFE_OFFSET(ARRAY_LENGTH(SPLIT(order_channel_path_nondirect, ' / ')) - 1)] AS last_channel_order_window_nondirect,
    SUM(order_count) OVER (PARTITION BY best_id) AS total_order_count,
    MAX(duration) OVER (PARTITION BY best_id, rolling_order_window) AS last_duration,
    MAX(return_date) OVER (PARTITION BY best_id, rolling_order_window) AS last_return_date,
    MAX(CASE WHEN order_count > 0 THEN session_timestamp END) OVER (PARTITION BY best_id, rolling_order_window) AS last_purchase_date,
    MAX(CASE WHEN bounced_session = 0 THEN session_timestamp END) OVER (PARTITION BY best_id, rolling_order_window) AS last_engaged_session_date,
    CASE 
      WHEN (SUM(order_count) OVER (PARTITION BY best_id, rolling_order_window)) > 0 THEN TRUE
      ELSE FALSE END AS purchaser, -- Has purchased ever
    CASE
      WHEN SUM(order_flag) OVER (PARTITION BY best_id ORDER BY session_timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) > 1 THEN TRUE
      ELSE FALSE END AS repeat_purchaser,
    CASE
      WHEN MAX(repeat_booking_mi) OVER (PARTITION BY best_id, first_order_window) > 0 THEN TRUE
      ELSE FALSE END AS repeat_purchaser_mi
  FROM join_channels_to_main_branch
  GROUP BY ALL
),

-- New CTE branch to get an array of all return dates by best_id
    return_date_array AS (
    SELECT 
      best_id, 
      ARRAY_AGG(return_date ORDER BY return_date) AS future_return_dates_array
    FROM window_calculations
    WHERE return_date IS NOT NULL
    GROUP BY best_id
    ),

    -- New CTE branch to get an array of all return dates by best_id
    departure_date_array AS (
    SELECT 
      best_id, 
      ARRAY_AGG(departure_date ORDER BY departure_date) AS future_departure_dates_array
    FROM window_calculations
    WHERE return_date IS NOT NULL
    GROUP BY best_id
    ),

-- Join back to the main table, but only when the session timestamp is 5+ days after the last return date
check_return_dates AS (
SELECT 
  a.*, 
  ARRAY_TO_STRING(ARRAY(SELECT CAST(dt AS STRING) FROM UNNEST(b.future_return_dates_array) AS dt), ', ') AS return_dates,
  ARRAY_TO_STRING(ARRAY(SELECT CAST(dt AS STRING) FROM UNNEST(c.future_departure_dates_array) AS dt), ', ') AS departure_dates,
   (
    SELECT MAX(return_timestamp)
    FROM UNNEST(future_return_dates_array) AS return_timestamp
    WHERE return_timestamp < session_timestamp) AS last_return_before_session,
  IF (
    session_timestamp >= TIMESTAMP_ADD((
      SELECT MAX(return_timestamp)
      FROM UNNEST(future_return_dates_array) AS return_timestamp
      WHERE return_timestamp < session_timestamp),INTERVAL 5 DAY),TRUE,FALSE) AS returned_home_5d_plus
FROM window_calculations AS a
LEFT JOIN return_date_array AS b
  ON a.best_id = b.best_id
LEFT JOIN departure_date_array AS c
  ON a.best_id = c.best_id
),

-- add various daily channel calculations
first_last_daily_channel AS (
SELECT * FROM (
  SELECT
    date,
    best_id,
    LAST_VALUE(channel) OVER user_day_window AS last_daily_channel,
    FIRST_VALUE(channel) OVER user_day_window AS first_daily_channel,
    ROW_NUMBER() OVER user_day_window AS rn
  FROM check_return_dates
  WINDOW user_day_window AS (PARTITION BY date, best_id ORDER BY session_timestamp 
  )
)
WHERE rn = 1
),

join_daily_channel AS (
SELECT
  a.*,
  b.last_daily_channel,
  b.first_daily_channel,
  FROM check_return_dates AS a
LEFT JOIN first_last_daily_channel AS b
  ON a.best_id = b.best_id
  AND a.date = b.date
),

get_prev_daily_channel AS (
SELECT
  date,
  best_id,
  last_daily_channel,
  LAG(last_daily_channel) OVER (PARTITION BY best_id ORDER BY date) AS previous_last_daily_channel 
FROM join_daily_channel
GROUP BY date, best_id, last_daily_channel
),

join_prev_channel AS (
SELECT
  a.*,
  b.previous_last_daily_channel
FROM join_daily_channel AS a
LEFT JOIN get_prev_daily_channel AS b
  ON a.date = b.date
    AND a.best_id = b.best_id
),

-- add engaged metrics windows
add_timebased_calculations AS (
SELECT 
  *,
  CASE WHEN session_timestamp = MIN(session_timestamp) OVER (PARTITION BY best_id) THEN 1 ELSE 0 END AS first_visit_events,
  CASE -- Has made a purchase in the last 12 months
  WHEN last_purchase_date BETWEEN TIMESTAMP_SUB(session_timestamp, INTERVAL 365 DAY) AND session_timestamp THEN TRUE ELSE FALSE END AS purchased_last_12m,    
  CASE -- Has made a purchase in the last 90 days
  WHEN last_purchase_date BETWEEN TIMESTAMP_SUB(session_timestamp, INTERVAL 90 DAY) AND session_timestamp THEN TRUE ELSE FALSE END AS purchased_last_90d,
  CASE -- Has made a purchase in the last 30 days
  WHEN last_purchase_date BETWEEN TIMESTAMP_SUB(session_timestamp, INTERVAL 30 DAY) AND session_timestamp THEN TRUE ELSE FALSE END AS purchased_last_30d,    
  CASE -- Has engaged session in the last 30 days
  WHEN (CASE WHEN engaged_flag IS TRUE THEN session_timestamp END)
    BETWEEN TIMESTAMP_SUB(session_timestamp, INTERVAL 30 DAY) AND session_timestamp THEN TRUE ELSE FALSE END AS has_engaged_session_last_30_days,
  CASE -- Has engaged session in the last 90 days
  WHEN (CASE WHEN engaged_flag IS TRUE THEN session_timestamp END)
    BETWEEN TIMESTAMP_SUB(session_timestamp, INTERVAL 90 DAY) AND session_timestamp THEN TRUE ELSE FALSE END AS has_engaged_session_last_90_days,
  CASE -- Has engaged session in the last 365 days
  WHEN (CASE WHEN engaged_flag IS TRUE THEN session_timestamp END)
    BETWEEN TIMESTAMP_SUB(session_timestamp, INTERVAL 365 DAY) AND session_timestamp THEN TRUE ELSE FALSE END AS has_engaged_session_last_365_days,
  CASE -- Has engaged crm in the last 30 days
  WHEN (CASE WHEN engaged_flag IS TRUE AND channel IN ("Brand - Email", "Brand - Web Push", "Brand - SMS", "Brand - Mobile Push", "Brand - App Share", "Brand - Whatsapp") THEN session_timestamp END)
    BETWEEN TIMESTAMP_SUB(session_timestamp, INTERVAL 30 DAY) AND session_timestamp THEN TRUE ELSE FALSE END AS has_engaged_crm_last_30_days,
  CASE -- Has engaged crm in the last 90 days
  WHEN (CASE WHEN engaged_flag IS TRUE AND channel IN ("Brand - Email", "Brand - Web Push", "Brand - SMS", "Brand - Mobile Push", "Brand - App Share", "Brand - Whatsapp") THEN session_timestamp END)
    BETWEEN TIMESTAMP_SUB(session_timestamp, INTERVAL 90 DAY) AND session_timestamp THEN TRUE ELSE FALSE END AS has_engaged_crm_last_90_days,
  CASE -- Has engaged crm in the last 365 days
  WHEN (CASE WHEN engaged_flag IS TRUE AND channel IN ("Brand - Email", "Brand - Web Push", "Brand - SMS", "Brand - Mobile Push", "Brand - App Share", "Brand - Whatsapp") THEN session_timestamp END)
    BETWEEN TIMESTAMP_SUB(session_timestamp, INTERVAL 365 DAY) AND session_timestamp THEN TRUE ELSE FALSE END AS has_engaged_crm_last_365_days
FROM join_prev_channel
)

-- final query
SELECT * FROM add_timebased_calculations

